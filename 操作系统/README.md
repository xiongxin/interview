
课程来源：https://www.xuetangx.com

# 第一讲 操作系统概述

## 1.2 什么是操作系统

### 操作系统内核特征

- 并发
- 共享
    - 同事访问
    - 互斥共享
        - 数据总线任何个时候只有一个应用去访问存储单元(微观上的互斥)
- 虚拟
    - 分时运行
- 异步

## 1.7 操作系统结构


# 第三讲 启动、中断、异常、和系统调用

## 3.1 BIOS

加电之后启动BIOS固件，初始化两个寄存器的值：CS：IP = oxf000:fff0.(CS:代码段寄存器(代码执行起点), IP: 质量指针寄存器)

系统处于实模式，在实模式下
程序计数器寄存器PC: 代码段寄存器左移4位加上IP寄存器值作为
即：PC = 16*CS+IP为BIOS启动后的第一条指令执行位置。

限制：20位地址空间

BIOS读取加载程序(bootloader)通过识别文件系统类型读取到操作系统内核镜像

控制权转移到操作系统内核代码

## 3.2 系统启动流程

## 3.3 中断、异常、系统调用比较

- 系统调用(system call) **异步或同步**
    - 应用程序**主动**向操作系统发出的服务请求
- 异常(exception) **同步**
    - 非法指令或者其他原因导致当前指令执行失败(如：内存出错)后的处理请求
- 中断(hardware interrupte) **异步**
    - 来自硬件设备的处理请求


### 系统调用的开销(高于用户普通函数调用)

- 硬件需要切换引导机制
- 建立内核堆栈
- 验证参数
- 内核态映射到用户态的地址空间
    - 更新页面映射权限
- 内核态独立地址空间
    - TLB


- CPU执行操作系统代码的时候称为处理机处于管态，内核态又称为管态
- 函数调用并不会切换到内核态，而除零操作引发中断，中断和系统调用都会切换到内核态进行相应处理。
- 应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。 以ucore OS为例，在lab1的challenge练习中和lab5中，系统调用机制的初始化也是通过建立中断向量表来完成的（可查看lab1的challenge的答案中在trap.c中idt_init函数的实现），中断向量表描述了但应用程序产生一个用于系统调用的中断号时，对应的中断服务例程的具体虚拟地址在哪里，即建立了系统调用的中断号和中断服务例程的对应关系。这样当应用程序发出类似 “int 0x80”这样的指令时（可查看lab1的challenge的答案中在init.c中lab1_switch_to_kernel函数的实现），操作系统的中断服务例程会被调用，并完成相应的服务（可查看lab1的challenge的答案中在trap.c中trap_dispatch函数有关“case T_SWITCH_TOK:”的实现）。
- 系统调用相对常规函数调用执行开销要大，因为这会涉及到用户态栈和内核态栈的切换开销，特权级变化带来的开销，以及操作系统对用户态程序传来的参数安全性检查等开销。如果发出请求的请求方和应答请求的应答方都在内核态执行，则不用考虑安全问题了，效率还是需要的，直接用常规函数调用就够了。 以ucore OS为例，我们可以看到系统调用的开销在执行“int 0x80”和“iret”带来的用户态栈和内核态栈的切换开销，两种特权级切换带来的执行状态（关注 kern/trap/trap.h中的trapframe数据结构）的保存与恢复等（可参看 kern/trap/trapentry.S的__alltraps和__trapret的实现）。而函数调用使用的是"call"和“ret”指令，只有一个栈，不涉及特权级转变带来的各种开销。如要了解call, ret, int和iret指令的具体功能和实现，可查看“英特尔 64 和 iA-32 架构软件开发人员手册卷 2a's,指令集参考（A-M）”和“英特尔64 和 iA-32 架构软件开发人员手册卷 2B’ s,指令集参考（N-Z）”一书中对这些指令的叙述。


## 3.5 系统调用示例

## 第5讲 物理内存管理：连续内存分配

 